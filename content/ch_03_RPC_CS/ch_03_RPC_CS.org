#+BIBLIOGRAPHY: ../bib plain

\begin{frame}[title={bg=Hauptgebaeude_Tag}]
  \maketitle
\end{frame}


* RPC

** RPC basics 
*** How to bring order to chaos 

- Direct communication can lead to unstructured distributed programs
  ("spaghetti sockets") 

- Instead: Take the client/server principles and provide a tighter
  integration  with the used programming language  
  - Instead of sending a request/receive a reply: Call a function
  - Instead of receiving a request/sending a reply: Execute a function, possibly with parameters, and return function results 
  -  Function call may be executed at a remote server


*** Remote Procedure Call/Remote Method Invocation

Idea formalized as 
 - \ac{RPC} in procedural languages
 - \ac{RMI} in object-oriented languages
   - Main difference to RPC: the *invoked object* has to be specified
     somehow
   - akin to *this* pointer in C++, *self* in Python, ...  local
     method invocation 
 - Core idea introduced in 1984, Birrell & Nelson
   \cite{Birrell:1984:IRP:2080.357392}

*** Reminder: Local procedure call 

Local: Caller and callee can access same address space (e.g., are part
of the same process) 
- Call works by jump to start of the procedure
  - Parameters passed in memory, on stack, in both directions 
  - Caller and callee can access that shared memory 


#+CAPTION: Local procedure call (one address space)
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:localcall
[[./figures/localcall.pdf]]


*** Goal of RPC 

Allow procedure calls across address spaces 
- Process in address space 1 can call procedure P running in a process
  with another address space 
- Advantage: No need to reorganise interaction between disjunct
  address spaces
- Challenge: Binding procedure P at runtime to calling process


#+CAPTION: Idea of remote procedure call
#+ATTR_LaTeX: :width 0.7\linewidth
#+NAME: fig:ideaRPC
[[./figures/ideaRPC.pdf]]


*** Practical requirement for RPC: Transparency 

- Ideally, neither caller nor callee can distinguish a local call from
  a remote call
  - I.e., caller behaves identically
    - Writes parameters to stack, jumps, retrieves result from stack
  - I.e., callee sees no difference
    - Is invoked with parameters and return address on stack, puts
      result back on stack 
  - Neither should have to bother with *transport* part of RPC 
- A *transparency* requirement 
      


*** Transparency by proxies       

- To ensure transparency, *proxies* are introduced
  - Shielding caller, callee from RPC details
  - Can still be calling/called locally
  - Pretend to be the missing piece 
- Proxy on caller side: *stub*
  - Pretends to be called function 
- Proxy on callee side: *skeleton* 
  - Pretends to be calling function
  - Often, in infinite loop
- Stub and skeleton together realize data transport 

*** RPC by proxy 


#+CAPTION: Remote procedure call enabled by proxies
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:rpc_proxy
[[./figures/RPCproxy.pdf]]


** RPC parameter passing 


*** Marshalling 
 Marshalling: taking parameters/results of a procedure call and prepare them for transmission over a network
 - To ensure, e.g., transparency between different hardware, operating systems, programming languages
 - Handled by client stub & server stub/skeleton 


*** Parameter passing  semantics 

- Value parameters of function: Copy to callee
  - Simple.
- Reference parameters: Not possible, address space isolation 
  - Copy to callee
  - Callee might modify!
  - Restore back to caller
  - So-called *copy-and-restore* semantics 


*** Parameter passing semantics: Challenges 

- How to deal with size?
- How to deal with pointer-based data structures?
  - E.g., a binary tree is passed as a pointer (reference!) in many
    languages
  - E.g., copy and restore entire tree when only one field of root
    node is interesting? 

*** Copy and restore: Equivalent semantics? 

Challenge:  Does *call by copy-and-restore* provide exact same
semantics as *call by reference*? 


#+BEAMER: \pause

No! 

#+BEGIN_SRC C
int a=42; 
void f(int *x, int *y) {
  *x++; *y++; }

f(&a, &a);
#+END_SRC

*** RPC Interface Definition Languages 

- Need: describe interface of functions to be called more explicitly
  - More precise calling semantics
    - Distinguish between in, out, in-out parameters 
  - Helps in heterogeneous contexts
    - Multiple languages
    - Multiple architectures (e.g., byte ordering!)
  - Allows custom-tailored marshalling for certain data types 

- External languages, or built into a programming language 


*** Alternative parameter passing semantics 

Alternative ideas exist 


- Idea: long address formats
#+BEAMER: \pause
  - Address encodes machine, process ID, and address inside process
  - Applicable to both RPC and RMI 


** RPC protocol  
   :PROPERTIES:
   :CUSTOM_ID: sec:rpp_protocol
   :END:

*** RPC execution semantics 
    :PROPERTIES:
    :CUSTOM_ID: s:rpc_execution
    :END:

What if things go wrong? 

- Local calls: executed *exactly once*
  - More precisely: *fate sharing* between caller and callee
- Remote calls: Problem is failures 
  - Maybe executed?
  - At least once?
  - At most once? 

*** Source of failures

- Request message is lost
- Reply message is lost
- Server/callee  crashes (but client survives)
- Client/caller  crashes (but server survives) 


*** RPC request/reply protocol 

- Basic idea: Caller  re-issues request when no reply has been
  received 
- Details: *RPC request/reply protocol* 


*** RPC request/reply: no errors

****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:
***** No errors                                                       :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:

- Simplest case 
- Set timeout when sending request to prepare for failures 

*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:



#+CAPTION: Simplest case: request/reply without errors
#+ATTR_LaTeX: :width \linewidth :page 1
#+NAME: fig:rpc_rrp_noerrors
[[./figures/rpc_rrp.pdf]] 




*** RPC request/reply: request lost

****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:
*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:

- When no reply, resend request after timeout  

*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:



#+CAPTION: Request/reply, timeout on request  
#+ATTR_LaTeX: :height 0.6\textheight :options page=2
#+NAME: fig:rpc_timeout_request
[[./figures/rpc_rrp.pdf]] 


*** RPC request/reply: reply lost

****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:
*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:

- Lost reply indistinguishable from lost request
- Resending request
- Simple case: just recompute result 
- Need *idempotent* function!
  - $\forall x: f(f(x)) = f(x)$

*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:



#+CAPTION: Request/reply with reply lost, recompute 
#+ATTR_LaTeX: :height 0.6\textheight :options page=3
#+NAME: fig:rpc_rrp_noerrors
[[./figures/rpc_rrp.pdf]] 


*** RPC request/reply: reply lost

****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:
*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:

- If recomputing infeasible, need to a *reply cache* for previous
  answers
- Need to be able to identify request and pertaining answer! 

*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:

#+CAPTION: Request/reply, reply cache 
#+ATTR_LaTeX: :height 0.5\textheight :options page=4
#+NAME: fig:rpc_rrp_noerrors
[[./figures/rpc_rrp.pdf]] 


*** RPC request/reply: server crash 

****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:
*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:

- Crashing server needs to be restarted 
  - Detection: Periodic heartbeating
  - On same or different machine (beware networking!) 


*****                                                        :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:

#+CAPTION: Request/reply, server restart
#+ATTR_LaTeX: :height 0.5\textheight :options page=5
#+NAME: fig:rpc_rrp_noerrors
[[./figures/rpc_rrp.pdf]] 



*** RPC request/reply: key ingredients 

- *Timeout* and *sequence numbers* for requests and replies
- Means to *recompute results* or *cache results*
- *Reply cache*: When to remove entries?
  - When will no resending of a request happen?
    - After having seen a bigger sequence numbers
    - Or after assumptions on timeout and network lifetime of packets 
- Means to *restart a server*
  - Typical: *heartbeating* 

** Acknowledgements 
   :PROPERTIES:
   :CUSTOM_ID: sec:acknowledgements
   :END:

*** Detour: Acknowledgement protocol 

- Scenario: Simple ACK protocol with timeouts
  - Sequence numbers 0 or 1
  - Messages never lost, but can be delayed arbitrarily 
- Operation:
  - When packet expected sequence arrives, ACK it and use packet 
  - Else, it is a retransmission \textendash{} resend ACK and drop packet 
- Does this work? 


*** Benign scenarios 



****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:



#+CAPTION: No problems
#+ATTR_LaTeX: :height 0.6\textheight :options page=1,keepaspectratio
#+NAME: fig:ack:noproblem
[[./figures/acks.pdf]]



*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:


#+CAPTION: Paket delay gets repaired
#+ATTR_LaTeX: :height 0.6\textheight :options page=2,keepaspectratio
#+NAME: fig:ack:paketdelay
[[./figures/acks.pdf]]

*** Infeasible scenario 


#+CAPTION: Uncoverable problem 
#+ATTR_LaTeX: :height 0.6\textheight :options page=3,keepaspectratio
#+NAME: fig:ack:unrecoverable
[[./figures/acks.pdf]]


*** Repair? 

- Problem in Figure \ref{fig:ack:unrecoverable} due to insufficient
  sequence numbers
- Bigger sequence number space would solve this problem

**** Solved? 

- But then, just make scenario correspondingly bigger
  - Yes, it does get less and less likely!
- Only possibility!

**** Impossible!                                                  :B_theorem:
     :PROPERTIES:
     :BEAMER_env: theorem
     :END:

With finite sequence numbers and arbitrary delays, dependable packet
delivery is not possible! But risk can be made arbitrarily small by
increasing sequence number space. 

*** Consequence? 

- For hint that *exactly once* delivery is perhaps not as simple as it
  looks like
- In fact, it is *fundamentally impossible*!
  - We will revisit this in the context of consensus 

*** Consequence of impossiblity? 

- *Exactly once* is unachievable
  - Do not believe marketing
- *At least once* strictly speaking also
  - Once the cable is cut, it is cut
  - Assumptions: Network partitions do not last arbitrarily long
- *At most once* feasible as well 


** RPC binding 

*** TODO RPC binding 

How does RPC stub know where to find its skeleton? 
- Aspect 1: correct machine 
  - Statically configured IP? 
  - Static DNS name?
- Aspect 2: correct process
  - Compare server activation (Section
    \slideref{sec:server_structure}[s:server_activation]) 

We will revisit *binding* and *service discovery* later 



*** RPC as middleware 
 RPCs present a more abstract view of a distributed system than a request/reply protocol directly realized with sockets 
 - New programming model! 
 - Collection of software realizing such a new programming model is a *middleware* 
 - Can achieve, e.g., transparency towards location, communication protocols, hardware, operating system, different programming languages, … 




* From RPC to RMI
*** Remote Method Invocation & Distributed objects
Goal: provide a distributed version of the object model made available by object-oriented programming languages
 
Ingredients of a “normal” object model (think: Java, C++, …)
 - Program: Collection of objects, each with data & methods,
   interacting with each other by means of method invocations
 - Object references: Necessary to access (identify) any object 
 - Interfaces: Defines signature of a set of methods, possibly
   implemented by a class 
 - Action: Invoke a method; effects: state change, new instance created, further method invocations 
 - Exceptions
 - Garbage collection
*** Distributed objects 
 In OO: state of a process is collection of the state of its objects 
 - State is separated anyway
 - Separating this state further onto different processes (and possibly machines) is the natural extension leading to distributed objects 
 - Entails some limitations, e.g., no direct data access into objects, only methods 
 - Provides new possibilities, e.g., replicating an object to several
   machines 

*** Distributed object model
 Interacting objects are no longer in a single process, but distributed onto several processes 
 - Requires appropriate notions of 
   - *Remote object reference*: Unique identifier of an instance in the entire distributed system, not only within a single process 
     - Might contain: IP address, process ID, object ID within this process
     - Compare long address formats 
   - *Remote interface*: Contains methods that are remotely invocable 
     - Object might have an additional local interface 
     - Typically specified in an IDL 

*** Distributed object model (2) 

 Requires appropriate notions of
 - *Actions* in a distributed object system
 - *Method* invocations might cross several process boundaries 
 - Where/in which process is a new object *instantiated*? 
   - E.g., in the process from which instantiation was requested? 
   - At a remote process (via a “proxy instantiator”?)
 - *Exceptions* transported from one process to another
   - Distribution itself will cause new forms of exception, e.g., timeouts – make them visible to programmer or not?
 - Distributed *garbage collection*
 
*** RMI design issues: Invocation semantics 

 - Local method invocations: Executed exactly once
 - Remote method invocations: Similar to RPC
   - Compare discussion on details of request/reply protocol \slideref{sec:rpp_protocol}[s:rpc_execution]
 - Issues: retry request message, duplication filtering, reexecute/history for retransmitting reply messages
 - Possible resulting semantics: maybe, at-least-once, at-most-once (exactly-once not possible in distributed systems!) 

*** RMI protocol implementation 

 In principle: Very similar to RPC implementation 
 - In detail: Middleware needs to provide some extra functionality to deal with remote object references, details of object lifetime, etc. 
 - E.g., how to obtain a remote object reference in the first place?
   - A binder service can provide such bootstrapping (e.g., RMIregistry) 

   
* Examples

** JavaRMI 
*** Case study: Java RMI 
 - Goal: Extend Java’s object model to a distributed one 
 - Some design decisions
   - Limited transparency 
     - Caller and callee know about their remote relationship: Caller must handle RemoteExceptions, callee must implement the Remote interface
     - Parameter-passing semantics differs between local and remote invocations 
   - Single-language design 
     - No interoperability with other languages 
     - No separate interface definition language necessary 
   - Classes not locally available can be loaded via the network 
   - Dedicated service to lookup remote object references – rmiregistry 

*** Remote interfaces   
 Remote interfaces in RMI 
 - Defined by extending the Remote interface (from java.rmi package)
   - Methods in interface must (at least) throw ~RemoteException~
   - Remote interfaces can have remote objects as parameters

*** Parameter passing 
 - Parameter and result passing
   - Marshalling happens via serialization:  any input parameter or result must implement the ~Serializable~ interface 
   - Missing classes are downloaded 
   - Remote references can be passed between remote interfaces ! method invocations on these references will result in remote method invocations; reference is passed by-value 
   - Non-remote objects are serialized, copied, and passed by-value 

***  RMIregistry 
- RMIregistry provides remote references to remote objects 
  - An instance must run on any computer hosting remote objects 
  - Essentially a table, mapping textual object names to real remote references 
- Accessed via the ~Naming~ class 
  - Core methods
    - ~bind/rebind~: put an entry into the table, making the invoker’s local object remotely accessible 
    - ~lookup~: provides a remote object reference, matching a given textual description to the invoking client 
  - Location of the server computer/rmiregistry must be known to the client program! 
  - I.e., IP address & port number (usually default 1099 is used)

*** Java RMI flow of invocations



#+CAPTION: Call sequence of a JavaRMI method invocation
#+ATTR_LaTeX: :height 0.6\textheight
#+NAME: fig:rmi_sequence
[[./figures/rmi.pdf]]

** Zerorpc 

*** zerorpc 
An example for a simple RPC/RMI libarary: zerorpc


**** Zerorpc                                                        :B_quote:
     :PROPERTIES:
     :BEAMER_env: quote
     :END:
zerorpc is a light-weight, reliable and language-agnostic library for distributed communication between server-side processes. It builds on top of ZeroMQ and MessagePack. Support for streamed responses – similar to Python generators – makes zerorpc more than a typical RPC engine. Built-in heartbeats and timeouts detect and recover from failed requests. Introspective capabilities, first-class exceptions and the command-line utility make debugging easy.


http://www.zerorpc.io

*** HelloWorld 


From http://www.zerorpc.io

Note: port number identifies object 

\small 
****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:


***** Server                                                          :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:

#+BEGIN_SRC python
import zerorpc

class HelloRPC(object):
    def hello(self, name):
        return "Hello, %s" % name

s = zerorpc.Server(HelloRPC())
s.bind("tcp://0.0.0.0:4242")
s.run()
#+END_SRC

***** Client                                                          :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:

#+BEGIN_SRC python 
import zerorpc

c = zerorpc.Client()
c.connect("tcp://127.0.0.1:4242")
print c.hello("RPC")
#+END_SRC


*** Streaming  


****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:

\small
***** Server                                                          :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:

#+BEGIN_SRC python
import zerorpc

class StreamingRPC(object):
    @zerorpc.stream
    def streaming_range(self, fr, to, step):
        return xrange(fr, to, step)

s = zerorpc.Server(StreamingRPC())
s.bind("tcp://0.0.0.0:4242")
s.run()
#+END_SRC

***** Client                                                          :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:

#+BEGIN_SRC python 
import zerorpc

c = zerorpc.Client()
c.connect("tcp://127.0.0.1:4242")

for item in c.streaming_range(10, 20, 2):
    print item
#+END_SRC


*** Basic structure 

- Wire layer (transport)
  - Combines 0mq for actual data exchange; msgpack for serialization of messages 
- Event layer 
  - Heart-beating, events, multiplexing 
  - Congestion control via buffering 
- RPC Layer as such 
  - Events: request, response, error 
  - STREAM support: Server keeps sending responses 


** Thrift 

*** Case study: Apache Thrift 

- Java :-(); 
- https://thrift.apache.org



** Tornado                                                         :noexport:

*** Python Tornado 




* WebServices: A tale from the past

*** One upon a time: Web services 

- Situation: Many interesting services offered in the WWW
  - Travel example: Web sites for flight booking, rental cars,
    hotels, ... 
  - Shipping company example: Ordering application and shipping cost
    application – manual reentering vs. program integration 

- But only accessible for humans – not easy to access such web sites
  from a program for further processing  
  - (Just imagine parsing a complex HTML page of a flight booking site
    to identify available flights ...) 


*** Web services to the rescue… 

Remedy: Web services
 - Provide a standard way of interacting between clients and servers that can be easily integrated into arbitrary programs
 - Use standard Web-based infrastructure to do so
 - Instead of RPC-like mechanisms 

*** Web Service: Definition (ca. 2004)  


**** Web Service \cite{WebServi22:online}                                       :B_definition:
     :PROPERTIES:
     :BEAMER_env: definition
     :END:
A Web service is a software system designed to support interoperable machine-to-machine interaction over a network.


It [Web Service] has an interface described in a machine-processable format (specifically WSDL). Other systems interact with the Web service in a manner prescribed by its description using SOAP-messages, typically conveyed using HTTP with an XML serialization in conjunction with other Web-related standards.





*** Infrastructure and components for Web services 


****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:


*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:
 Required
 - A *transport protocol* between client and server
   - Often: HTTP (over TCP over IP) – but alternatives exist 
 - A *representation syntax* how to format service invocations and answers 
   - Often: \ac{SOAP}, written out in XML 
 - A means to *describe* & *find* web services
   - \ac{WSDL} & \ac{UDDI}

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:


#+CAPTION: Structure of Web service components
#+ATTR_LaTeX: :width 0.8\linewidth
#+NAME: fig:webservice_structure
[[./figures/wsdl.pdf]]



*** Representation: SOAP 

- A formalism to describe messages, to be used in request/reply
  protocol
- Self-describing messages 
- /Extremely/ talkative 
- Being carried over HTTP, easily  traverses firewalls 

*** Describing and finding Web services 

- We need an IDL: WSDL
  - Defines interfaces, parameter passing semantics, ... 
    - similar to RPC, RMI ideas
  - XML-based notation
  - Also defines bindings (no registry needed, but no late binding possible)
  - Relatively complicated, multi-stage definition 
- We need to find WDSLs and binding 
  - Late Binding /through the backdoor/

*** Comparison: Web services and distributed object model

 - At first glance: Very similar -– Web service is but an interface to
   a remote object 
 - But some subtle differences exist
   - Web services are essentially a single remote object –- they cannot
     be instantiated to form “new services”, no remote object
     references, no garbage collection, ... 
   - Transport protocols and syntax can be vastly different 
   - Distributed object systems usually use proprietary protocols for interaction between objects, not HTTP/XML/SOAP 

*** A look back 

- WebServices (as XML/SOAP/WSDL/UDDI) was once considered the saviour
  of complex IT systems 
- But turned out way too complicated 


* Today's tale: REST

*** A variation on the web services theme: REST

- Web services can use complex interfaces 
  - Specified with SOAP, WSDL
  - Allow complex interaction relationships between users and
    providers of such services 
- Beauty in simplicity?
  - Use a very restricted interface set:  \ac{CRUD}
    - Sounds like GET, PUT, DELETE, POST? 
  - Concentrate on the manipulation of data through such a simple interface
    - When accessing a data resource, the entire resource is provided
      (i.e., web page is downloaded) and can then be locally
      manipulated instead of complex interface operations  

- Realized in Representational state transfer (REST) \cite{Fielding:2000:ASD:932295}

*** REST architecture: Constraints 

- Client/server
- Stateless 
  - I.e., server stores no client context between invocations 
- Caching 
  - Responses must define their cacheability 
- Layered system 
  - Client might talk to server or intermediary; unable to distinguish 
- Code on demand 
- Uniform interface
  - The KEY property of REST 

    
*** REST: Uniform interface 

- Identification of resources 
  - All resources are identified using a common namespace, e.g., URI
- Manipulation of resources through representations 
  - Based on a resource’s representation as obtained from server, client can process it (manipulate,...) 
- Self-descriptive messages 
  - Messages specify enough information to allow their processing (e.g., character set, media type, ...) 
- \ac{HATEOAS}
  - Resource representations contain enough information to discover
    further resources  
  - Client has no hard-coded information about structure or dynamics of the REST service 



*** Representations contain information to discover resources??

- What does that mean? 
- Practically speaking: 
  - A root resource exists 
  - Possible to ask it for a list of further, comprised resources 
  - And each resource might provide again such a list of comprised
    resources (resource tree")  
- Example: PAUL 
  - Root could tell: There are classes, room, students, lecturers,
    ... 
  - The "Lecturer" resource could provide a list of lecturers
  - Each individual lecturer could then provide details, e.g., a list
    of classes she/he teaches  


*** REST as specialisation of WebServices 
- REST-compliant Web services: the primary purpose of the service is
  to manipulate XML representations of Web resources using a uniform
  set of "stateless" operations 
  - W3C, Web Services Architecture
- Combining:  *RESTful web services*
  - A web service that adheres to the REST architectural constraints 
    - Base URL from which to discover further resources 
    - Media types explicitly specified
    - Use HTTP and standard HTTP request types to specify operations 
  - Think in terms of collections of individual resources 




*** RESTful: Collections, elements vs. HTTP methods 
 
\tiny 
 
#+ATTR_LATEX: :center 1 :booktabs 1 :align p{0.1\linewidth}p{0.15\linewidth}p{0.1\linewidth}p{0.1\linewidth}p{0.2\linewidth}p{0.1\linewidth}
| Uniform Resource Locator (URL)                            | GET                                                                                                                   | PUT                                                                                 | PATCH                                          | POST                                                                                                                          | DELETE                                         |
|-----------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------|
| Collection, such as https://api.example.com/resources/    | List the URIs and perhaps other details of the collection's members.                                                  | Replace the entire collection with another collection.                              | Not generally used                             | Create a new entry in the collection. The new entry's URI is assigned automatically and is usually returned by the operation. | Delete the entire collection.                  |
|-----------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------+------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------|
| Element, such as https://api.example.com/resources/item17 | Retrieve a representation of the addressed member of the collection, expressed in an appropriate Internet media type. | Replace the addressed member of the collection, or if it does not exist, create it. | Update the addressed member of the collection. | Not generally used. Treat the addressed member as a collection in its own right and create a new entry within it.             | Delete the addressed member of the collection. |


From \cite{RESTRepresen19:online}




*** RESTful: URL patterns 

- Compare URL patterns conventional and rest based 
- E.g., PAUL, resource “classes” 
  - Both patterns distinguish between collections and individual elements 


*** RESTful: URL patterns (2) 

- Conventional patterns: actions/verbs are part of the URL; with
  query/update in the HTTP action  
  - http://paul.upb.de/classes/ : gives list 
  - http://paul.upb.de/classes/add/   :  gives a form where to add new
    one (GET), or uploads the form (POST) 
  - http://paul.upb.de/classes/175/   :  gives details on class 175
  - http://paul.upb.de/classes/175/update  : gives details on class
    175 (GET) or uploads new details (POST)  
- RESTful: no actions in URL, expressed ONLY via HTTP action
  - http://paul.upb.de/classes/  :  gives list (GET); creates new 
    individual in this collection (POST)  
  - http://paul.upb.de/classes/175/  : gives details on class 175
    (GET), creates new one or update existing one (PUT)  




*** RESTful: URL patterns practically 

- In principle, nice idea 
  - A couple of pitfalls – e.g., how to obtain a Web form to fill in
    data for a new resource? Not nicely handled via REST 
- But problem with HTML/browser implementation
  - Typical: circumvented by Javascript in browser  
    


**** HTML snippet                                            :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:

\small 

#+BEGIN_SRC  html
 <html>
<body>
  <form action="form_handler.php" method=”POST">
    User Name: <input name="user" type="text" />
   <input type="submit"value="Submit" />
  </form>
 </body>
 </html>
#+END_SRC

But:  No DELETE, PUT,  ... supported!


*** RESTful: Interface descriptions? 

- In a sense: no interface description needed (in strict REST, HATEOAS) 
- In practice: you DO want to know what services exist, at which URIs,
  what their semantics is  
  - We DO need a description formalism 
- Options? 
  - WSDL? – sure, but failed in practice
  - Google, Apache, ... examples – sure 
  - SWAGGER (http://swagger.io) – currently extremely popular 
    - Foundation for OpenAPI specification 
    - Specification written as YAML file 
    - Tool chain + decent formalism + open source = success! 
    - Write API, get code and documentation automatically generated 
  - See also:
    http://apievangelist.com/2016/09/16/a-look-at-the-state-of-api-documentation-solutions/  

*** Swagger examples 


#+CAPTION: Screenshot of Swagger tutorial API example
#+ATTR_LaTeX: :width 0.7\linewidth
#+NAME: fig:swagger_screenshot
[[./figures/swagger-screenshot.png]]



*** Examples
 - Several popular sites provide Web services
   - Yahoo, Google, Ebay, Amazon, … 
 - Example: Access Google Maps’s API
   - You’ll need: 
     - a programming language that can curl a URL 
     - Interpret the resulting JSON


**** Example: Google Map Service                             :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
\small 

#+BEGIN_SRC python
 import requests
 import json
 
 r = requests.get("https://maps.googleapis.com/maps/api/geocode/json?address=Warbugrstr. 100, Paderborn") 
 
 print json.dumps(r.json(), indent=4)
#+END_SRC



* An architecture style: microservices

** Microservices 

*** Application scenario: Fake News Detector 



****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:



- Based on AI breakthroughs, the German government commissions
  development of \ac{FAD}
- Functionality:
  - Read in data from social media networks, preprocess (remote or locally)
  - Apply various AI algorithms to it
    - Must be easily replaceable
  - Detect Fake News Sources
  - Trigger alarms at intelligence  services 


*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:



#+CAPTION: Fake News Detector System
#+ATTR_LaTeX: :width 0.9\linewidth
#+NAME: fig:fad
[[./figures/fad.pdf]]



*** Monolithic architecture 




****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:

- Conventional architecture: Monolithic 
  - One big blob of functionality supporting all and everything in your application 
    - E.g.:3-tier web application with multitude of different clients
      (apps, mobile browser, ...)  
    - Problem: Code becomes unwieldy; needs unrealistic systems 

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:




#+CAPTION: HAL9000-based FAD system
#+ATTR_LaTeX: :width 0.9\linewidth
#+NAME: fig:fad_hal
[[./figures/fad_hal.pdf]]

*** So far: coarse-grained functional particion 



****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:


- Many webservers, many data analysis systems 
- Coupled by an intermediate storage system 

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:



#+CAPTION: FAD based on coarse-grained partitioning
#+ATTR_LaTeX: :width 0.9\linewidth 
#+NAME: fig:fad_coarse
[[./figures/fad_coarse.pdf]]





*** Microservices: Architecture pattern 

- Alternative: *\ac{MS}* 
  - Chop up big binary into independently runable instances, typically
    focused on a single functionality  
  - Link them together by *loose coupling*
  - Advantages: Simpler development, simpler scaling, better fault-tolerance 
  - See, e.g., http://microservices.io/patterns/microservices.html 
- *Recursive pattern*
- System vs. service: Commonly distinguished as stateful vs. stateless 


*** Chaining



****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:



- Key feature: Multiple microservices can be chained together into a
  new (micro-)service
- Different styles
  - *Orchestration*: Chaining done by one MS calling others
  - *Choreography*: MS talks directly to the next one 


*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.5
      :END:


#+CAPTION: Orchestration style
#+ATTR_LaTeX: :width 0.8\linewidth :options page=1
#+NAME: fig:ms_orchestration
[[./figures/orch_choreo.pdf]]


#+CAPTION: Choreography style
#+ATTR_LaTeX: :width 0.8\linewidth :options page=2
#+NAME: fig:ms_choreography
[[./figures/orch_choreo.pdf]]



*** Scalability: up and out 



****                                                              :B_columns:
     :PROPERTIES:
     :BEAMER_env: columns
     :END:

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.6
      :END:


- Simple example: linear chain of microservices 
  - Computation time per request: 10ms, 100ms, 10ms
- We need more computational power at middle service
  - *Scale up*: Get a faster machine
  - *Scale out*: Run multiple instance
    - Challenge: *Splitting* and *merging* 

*****                                                                 :BMCOL:
      :PROPERTIES:
      :BEAMER_col: 0.4
      :END:

#+CAPTION: Scaling out a microservice
#+ATTR_LaTeX: :width=0.8\textwidth :options keepaspectratio,page=3
#+NAME: fig:ms_scaling
[[./figures/orch_choreo.pdf]]


*** Challenges 


- When to run how many instances of which service doing which work? 
  - Buzzword: Stateless, autoscaling, load balancing  
- How to deal with crashing services? 
  - Buzzword: Automatic restart, Circuit breaker, Database per Service
- How to organize dependable, efficient message exchange between
  individual services?  
  - Buzzword: Messages/Events and for data handling, \ac{CQRS} 
- Stateful services?
  - Buzzword: (NoSQL-)Databases, CQRS


*** Database for microservices 

- Ok, so we have many fine-grained, scaled-out microservices 
- All communicating via a big, central database??
  - Needs a HAL9000 machine, again \textendash{} nothing gained 


#+BEAMER: \pause
- We have to get rid of the central database
- Stateful services need to store their own state in their own
  database
  - /System of systems/ rather than /service of service/

#+BEAMER: \pause
- Coupling of these services/systems happens typically via \ac{DES}
  (Chapter \ref{ch:pubsub}) or Message Queuing (Chapter \ref{ch:mq})


*** CQRS 

- Observation: Simple model of CRUD data stores insufficient for
  complex scenarios 
  - Read access: various aggressions, filters, ...
  - Update access: validation necessary, ensure consistency, ... 
- Might end up in different models to be used when querying or
  updating data
- Idea: separate the responsibilities at these actions; introduce
  different data models
  - Separate the responsibility for command and query
  - Nicely fits into DES 
- Mostly a software engineering issue, cp. e.g. \cite{CQRS61:online}


*** Microservices: So? 

Analogy 
- Windows: Rich clients, doing all kinds of things, but are not reusable 
- Unix: Small, highly focused tools that can be easily connected
  together (think: Pipelining of shell commands) 
  - Every Unix user wondered what the big deal about microservices is;
    that is how Unix works since the 1960s ... 



** Case study: Reactive 
*** Case study: Reactive Systems  

Case Study: Reactive Systems design pattern for distributed applications 
- Pushed by company TypeSafe http://www.typesafe.com 
- Warning: commercials ahead 


*** Reactive Systems – “Manifesto”

- Claim: Future distributed systems need to fulfil certain properties 
  - *Responsive*: Ability to respond to requests in timely manner, with
    reliable upper bounds on response times  
    - Sometimes formalized as: probability to meet a deadline 
  - *Resilient*: Responsiveness maintained in presence of failures 
    - Key mechanisms: Replication, containment, isolation, delegation 
    - Clients not burdened with handling failures 
  - *Elastic*: Responsiveness maintained under varying load by changing allocated resources
    - Predictive as well as reactive 
  - *Message-driven*: asynchronous message passing between components; provides loose coupling and isolation 
  - *Hierarchical structure*: Large systems made up of smaller ones 
- http://www.reactivemanifesto.org/ 
- Exercise: Compare this against the (decades old) list of
  transparency properties and reveal this list as marketing 


*** Typesafe reactive platform 
Interesting aspect: Typesafe built a platform to support such applications 
- http://www.typesafe.com/products/typesafe-reactive-platform 




#+CAPTION: Typesafe components
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:typseafe
[[./figures/typesafe.png]]


\pause 
Typesafe morphed into [[https://en.wikipedia.org/wiki/Lightbend][Lightbend]], but same basic ideas 


*** Typesafe: Actors programming model 



- At the core of Akka: Actor programming model 
  - Encapsulates state and behaviour 
  - No shared mutable state 
  - Only interact with each other via messages, atomically consumed
  - Only accessible via a reference, which hides location from other actors 
  - Key aspect: onReceive message 
  - Hierarchies: parent actor creates child actors, supervises them
    (e.g., for failures)   
    - Default supervision: restart on failure; can be customized 
    - Resume: state is maintained
    - All waiting messages for actor still there; only one message lost 
- What of this is new? 


*** Typesafe: ConductR – Cluster runtime 


- Interesting feature: A runtime for actors on a cluster
- Features 
  - Automatic load balancing 
  - Automatic restarts 
  - Interacts with clients via HTTP/Rest/JSON interfaces 
- Uses
  - Docker as container for components 
- In conclusion: The beef is in the tools, not the philosophy 


*** TODO Example: Snort as microservice or NFV                     :noexport:

- Not sure there is time for that? 


* Conclusion 

*** Conclusion 

- The simple idea of procedure calls translates to distributed
  settings
- Take care of
  - Execution semantics/failures
  - Parameter passing semantics
- Distributed object models are a fairly straightforward extension
- Reducing to simpler set of actions results in the RESTful model
- RESTful services can be nicely combined into microservices
  - With plenty of software engineering considerations 


* Notes                                                            :noexport:

- https://capnproto.org/rpc.html

- Come back to marshalling: Thrift 

