#+BIBLIOGRAPHY: ../bib plain

* RPC 

** RPC basics 
*** How to bring order to chaos 

- Direct communication can lead to unstructured distributed programs
  ("spaghetti sockets") 

- Instead: Take the client/server principles and provide a tighter
  integration  with the used programming language  
  - Instead of sending a request/receive a reply: Call a function
  - Instead of receiving a request/sending a reply: Execute a function, possibly with parameters, and return function results 
  -  Function call may be executed at a remote server


*** Remote Procedure Call/Remote Method Invocation

Idea formalized as 
 - \ac{RPC} in procedural languages
 - \ac{RMI} in object-oriented languages
   - Main difference to RPC: the *invoked object* has to be specified
     somehow
   - akin to *this* pointer in C++, *self* in Python, ...  local
     method invocation 
 - Core idea introduced in 1984, Birrell & Nelson
   \cite{Birrell:1984:IRP:2080.357392}

*** Reminder: Local procedure call 

Local: Caller and callee can access same address space (e.g., are part
of the same process) 
- Call works by jump to start of the procedure
  - Parameters passed in memory, on stack, in both directions 
  - Caller and callee can access that shared memory 


#+CAPTION: Local procedure call (one address space)
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:localcall
[[./figures/localcall.pdf]]


*** Goal of RPC 

Allow procedure calls across address spaces 
- Process in address space 1 can call procedure P running in a process
  with another address space 
- Advantage: No need to reorganise interaction between disjunct
  address spaces
- Challenge: Binding procedure P at runtime to calling process


#+CAPTION: Idea of remote procedure call
#+ATTR_LaTeX: :width 0.95\linewidth
#+NAME: fig:ideaRPC
[[./figures/ideaRPC.pdf]]


*** Practical requirement for RPC: Transparency 

- Ideally, neither caller nor callee can distinguish a local call from
  a remote call
  - I.e., caller behaves identically
    - Writes parameters to stack, jumps, retrieves result from stack
  - I.e., callee sees no difference
    - Is invoked with parameters and return address on stack, puts
      result back on stack 
  - Neither should have to bother with *transport* part of RPC 
- A *transparency* requirement 
      


*** Transparency by proxies       

- To ensure transparency, *proxies* are introduced
  - Shielding caller, callee from RPC details
  - Can still be calling/called locally
  - Pretend to be the missing piece 
- Proxy on caller side: *stub*
  - Pretends to be called function 
- Proxy on callee side: *skeleton* 
  - Pretends to be calling function
  - Often, in infinite loop
- Stub and skeleton together realize data transport 

*** RPC by proxy 


#+CAPTION: Remote procedure call enabled by proxies
#+ATTR_LaTeX: :width 0.75\linewidth
#+NAME: fig:rpc_proxy
[[./figures/RPCproxy.pdf]]


** RPC challenges 


*** Marshalling 
 Marshalling: taking parameters/results of a procedure call and prepare them for transmission over a network
 - To ensure, e.g., transparency between different hardware, operating systems, programming languages
 - Handled by client stub & server stub/skeleton 


*** Parameter passing  semantics 

- Value parameters of function: Copy to callee
  - Simple.
- Reference parameters: Not possible, address space isolation 
  - Copy to callee
  - Callee might modify!
  - Restore back to caller
  - So-called *copy-and-restore* semantics 


*** Parameter passing semantics: Challenges 

- How to deal with size?
- How to deal with pointer-based data structures?
  - E.g., a binary tree is passed as a pointer (reference!) in many
    languages
  - E.g., copy and restore entire tree when only one field of root
    node is interesting? 

*** Copy and restore: Equivalent semantics? 

Challenge:  Does *call by copy-and-restore* provide exact same
semantics as *call by reference*? 


#+BEAMER: \pause

No! 

#+BEGIN_SRC C
int a=42; 
void f(int *x, int *y) {
  *x++; *y++; }

f(&a, &a);
#+END_SRC

*** RPC Interface Definition Languages 

- Need: describe interface of functions to be called more explicitly
  - More precise calling semantics
    - Distinguish between in, out, in-out parameters 
  - Helps in heterogeneous contexts
    - Multiple languages
    - Multiple architectures (e.g., byte ordering!)
  - Allows custom-tailored marshalling for certain data types 

- External languages, or built into a programming language 



*** RPC execution semantics 

What if things go wrong? 

- Local calls: executed *exactly once*
  - More precisely: *fate sharing* between caller and callee
- Remote calls:
  - Maybe executed?
  - At least once?
  - At most once? 

We will revisit in Section \slideref{sec:rpc_faults}[s:rpc_protocols] 


*** RPC binding 

How does RPC stub know where to find its skeleton? 
- Statically configured IP? 
- Static DNS name?

We will revisit later 

*** RPC as middleware 
 RPCs present a more abstract view of a distributed system than a request/reply protocol directly realized with sockets 
 - New programming model! 
 - Collection of software realizing such a new programming model is a middleware 
 - Can achieve, e.g., transparency towards location, communication protocols, hardware, operating system, different programming languages, … 








* From RPC to RMI 
*** Remote Method Invocation & Distributed objects
 Goal: provide a distributed version of the object model made available by object-oriented programming languages
 - 
 - Ingredients of a “normal” object model (think: Java, C++, …)
 - Program: Collection of objects, each with data & methods, 
 - interacting with each other by means of method invocations 
 - Object references: Necessary to access (identify) any object 
 - Interfaces: Defines signature of a set of methods, possibly implemented by a call 
 - Action: Invoke a method; effects: state change, new instance created, further method invocations 
 - Exceptions
 - Garbage collection
*** Distributed objects 
 In OO: state of a process is collection of the state of its objects 
 - State is separated anyway
 - Separating this state further onto different processes (and possibly machines) is the natural extension leading to distributed objects 
 - Entails some limitations, e.g., no direct data access into objects, only methods 
 - Provides new possibilities, e.g., replicating an object to several machines 
*** Distributed object model
 Interacting objects are no longer in a single process, but distributed onto several processes 
 - Requires appropriate notions of 
 - Remote object reference: Unique identifier of an instance in the entire distributed system, not only within a single process 
 - Might contain: IP address, process ID, object ID within this process 
 - Remote interface: Contains methods that are remotely invocable 
 - Object might have an additional local interface 
 - Typically specified in a programming-language-neutral form to allow invocations from other programming languages – an 
 - interface definition language (IDL)
*** Distributed object model
 Requires appropriate notions of
 - Actions in a distributed object system
 - Method invocations might cross several process boundaries 
 - Where/in which process is a new object instantiated? 
 - E.g., in the process from which instantiation was requested? 
 - At a remote process (via a “proxy instantiator”?)
 - 
 - 
 - 
 - 
 - Exceptions transported from one process to another
 - Distribution itself will cause new forms of exception, e.g., timeouts – make them visible to programmer or not?
 - Distributed garbage collection 
*** RMI design issues: Invocation semantics 
 Local method invocations: Executed exactly once
 - Remote method invocations: Not so easy
 - Compare discussion on details of request/reply protocol
 - Issues: retry request message, duplication filtering, reexecute/history for retransmitting reply messages
 - Possible resulting semantics: maybe, at-least-once, at-most-once (exactly-once not possible in distributed systems!) 
*** RMI implementation 
 In principle: Very similar to RPC implementation 
 - In detail: Middleware needs to provide some extra functionality to deal with remote object references, details of object lifetime, etc. 
 - E.g., how to obtain a remote object reference in the first place? A binder service can provide such bootstrapping (e.g., RMIregistry) 

   
* Examples: Java RMI, zerorpc 
*** Overview
 Basics: Data exchange, sockets 
 - Client/server
 - Mechanisms 
 - Remote procedure call
 - Remote method invocation & distributed objects
 - Case study: Java RMI 
 - Case study: ZeroRPC
 - Case studies
*** Case study: Java RMI 
 Goal: Extend Java’s object model to a distributed one 
 - Some design decisions
 - Limited transparency 
 - Caller and callee know about their remote relationship: Caller must handle RemoteExceptions, callee must implement the Remote interface
 - Parameter-passing semantics differs between local and remote invocations 
 - Single-language design 
 - No interoperability with other languages 
 - No separate interface definition language necessary 
 - Classes not locally available can be loaded via the network 
 - Dedicated service to lookup remote object references – rmiregistry 
*** Java RMI – remote interfaces and parameters  
 Remote interfaces in RMI 
 - Defined by extending the Remote interface (from java.rmi package)
 - Methods in interface must (at least) throw RemoteException
 - Remote interfaces can have remote objects as parameters
 - Parameter and result passing
 - Marshalling happens via serialization ! any input parameter or result must implement the Serializable interface 
 - Missing classes are downloaded 
 - Remote references can be passed between remote interfaces ! method invocations on these references will result in remote method invocations; reference is passed by-value 
 - Non-remote objects are serialized, copied, and passed by-value 
 - 
*** Java RMI – RMIregistry 
 RMIregistry provides remote references to remote objects 
 - An instance must run on any computer hosting remote objects 
 - Essentially a table, mapping textual object names to real remote references 
 - Accessed via the Naming class 
 - Core methods
 - bind/rebind: put an entry into the table, making the invoker’s local object remotely accessible 
 - lookup: provides a remote object reference, matching a given textual description to the invoking client 
 - Location of the server computer/rmiregistry must be known to the client program! 
 - I.e., IP address & port number (usually default 1099 is used)
*** Java RMI – Overview 


 Lookup()

 Clientrechner
 Clientprogramm
 Call remote method

 - Stub

 Registry
 Serverrechner
 1099
 ObjImpl_Stub.class
 ObjImpl_skel.class
 ObjImpl.class
 - rebind(Obj)

 2. Wo ist das entfernte Objekt?
 3. Entferntes Objekt gefunden

 4. Anforderung Stub

 5. Lieferung Stub


 6. Rufe entfernte Methode auf


 7. Gebe das Ergebnis zurück
 1. Registrierung
*** Overview
 Basics: Data exchange, sockets 
 - Client/server
 - Mechanisms 
 - Remote procedure call
 - Remote method invocation & distributed objects
 - Case study: Java RMI 
 - Case study: ZeroRPC
 - Case studies
*** zerorpc 
 89
*** zerorpc: HelloWorld 
 Distributed Systems, Ch. 2:  Basic Interaction Patterns
 90
 Port number identifies object 
*** zerorpc: Streaming Reponses 
 Distributed Systems, Ch. 2:  Basic Interaction Patterns
 91
*** zerorpc: Basic structure 
 92


*** Case study: Apache Thrift 

- Java :-( ); 
- https://thrift.apache.org



*** Python Tornado 




* WebServices: A tale from the past 

*** One upon a time: Web services 

*** Web services to the rescue… 
 Remedy: Web services
 - Provide a standard way of interacting between clients and servers that can be easily integrated into arbitrary programs
 - Use standard Web-based infrastructure to do so
 - Instead of RPC-like mechanisms 
 - 
 - 
 - 
*** Web Service: Definition (ca. 2004)  
 96
*** Infrastructure and components for Web services 
 Required
 - A transport protocol between client and server
 - Often: HTTP (over TCP over IP) – but alternatives exist 
 - A representation syntax how to format service invocations and answers 
 - Often: SOAP, written out in XML 
 - A means to describe & find web services – WSDL & UDDI, covered later


*** Comparison: Web services and distributed object model
 At first glance: Very similar – Web service is but an interface to a remote object
 - 
 - But some subtle differences exist
 - Web services are essentially a single remote object – they cannot be instantiated to form “new services”, no remote object references, no garbage collection, … 
 - Transport protocols and syntax can be vastly different 
 - Distributed object systems usually use proprietary protocols for interaction between objects, not HTTP/XML/SOAP 
 - 
 - 


* Today's tale: REST                                               :noexport:

*** A variation on the web services theme: REST
 Web services can use complex interfaces 
 - Specified with SOAP, WSDL
 - Allow complex interaction relationships between users and providers of such services
 - 
 - Beauty in simplicity?
 - Use a very restricted interface set: create, read, update, delete (CRUD)
 - Sounds like GET, PUT, DELETE, POST ? 
 - Concentrate on the manipulation of data through such a simple interface
 - When accessing a data resource, the entire resource is provided (i.e., web page is downloaded) and can then be locally manipulated instead of complex interface operations 
 - 
 -  ! Realized in Representational state transfer (REST)
 - Fielding, Architectural Styles and the Design of Network-based Software Architectures, 2000
*** REST architecture: Constraints 
 114
*** REST: Uniform interface 
 115
*** Representations contain information to discover resources??
 116
*** REST as specialisation of WebServices 
 117
*** RESTful: Collections vs. HTTP methods 
 https://en.wikipedia.org/wiki/Representational_state_transfer, retrieved 2016-11-14
 nullipotent
 idem-
 - potent
 idem-
 - potent
 server 
 - chooses URI
 client
 - chooses URI
*** RESTful: URL patterns 
 119
*** RESTful: URL patterns practically 
 120

#+BEGIN_SRC  html
 <html>
<body>
  <form action="form_handler.php" method=”POST">
    User Name: <input name="user" type="text" />
   <input type="submit"value="Submit" />
  </form>
 </body>
 </html>
#+END_SRC

 No DELETE, PUT, 
 - ... supported!
*** RESTful: Interface descriptions? 
 121
*** Swagger examples 

*** Swagger examples 

*** Examples
 Several popular sites provide Web services 
 - Yahoo, google, ebay, Amazon, … 
 - Example: Access to Google’s Map api 
 - You’ll need: 
 - a programming language that can curl a URL 
 - Interpret the resulting JSON
 - 
 import requests
 - import json
 - 
 - r = requests.get(“https://maps.googleapis.com/maps/api/
 - geocode/json?address=Warbugrstr. 100, Paderborn")
 - 
 - print json.dumps(r.json(), indent=4)




* An architecture style: microservices                             :noexport:

*** Microservices: Architecture pattern 
 126
*** Microservices: Architecture pattern – So? 
 127


*** TODO Case study: Reactive Systems  

- Check, does this really belong here? 

*** Reactive Systems – “Manifesto”
 129
*** Typesafe reactive platform 
 130
 Programs, in Java or Scala, 
 - running on JVM 
 Data engine 
 Message-driven 
 - middleware, based on actors
 Web framework 
*** Typesafe: Actors programming model 
 131
*** Typesafe: ConductR – Cluster runtime 
 132


*** Example: Snort as microservice or NFV 

- Not sure there is time for that? 


* Notes 

- https://capnproto.org/rpc.html

- Come back to marshalling: Thrift 

