#+BIBLIOGRAPHY: ../bib plain


Issue: Leader election under Dealing with failues? Maybe move up to a
better place? 

** Distributed mutual exclusion 

*** Mutual exclusion in distributed systems
 Problem of mutual exclusion: when processes execute concurrently, there may be crucial portions of code which may only be executed by at most one process at any one time 
 - This/these piece(s) of code form a so-called critical region
 - In non-distributed systems: semaphores to protect such critical regions 
 - But this does not directly carry over to distributed systems! 
 - 
 - Options
 - Centralized algorithm
 - Distributed algorithm 
 - Token-Ring-based algorithm 
*** A centralized algorithm for mutual exclusion 
 Run a leader election algorithm, determine a coordinator for a critical region 
 - Known to everybody
 - Coordinator holds a token for the critical region 
 - Node who wants to enter into the region sends message to coordinator
 - If coordinator owns token, send it
 - Else, put request into a queue 
 - After leaving the critical region, send back token to coordinator 
 - 
*** Example: Mutual-Exclusion-Server

 p1
 p2
 p3
 p4
 Server

 Request 
 -           token

 2. Grant 
 -   token

 3. Request 
 -           token
 4
 Queue of
 - requests


 4. Request 
 -     token
 2

 5. Release  token

 6. Grant  token

 Token

*** Properties
 Mutual exclusion is achieved
 - Fair – requests are served in order 
 - Easy to implement
 - Per access to critical region, only three messages are required  
 Coordinator is single point of failure
 - When a requester is blocked, impossible to distinguish between a failed coordinator and a long queue
 - Coordinator becomes a performance bottleneck in large systems 
 - In particular when serving more than one critical region 
*** Distributed mutual exclusion
 How to achieve mutual exclusion without a coordinator? 
 - 
 - All processes use multicast 
 - All processes have a logical clock 
 - When trying to enter into the critical region
 - Send a request to all other nodes
 - All other nodes have to agree to such a request before a node may enter critical region 
*** Example distributed mutual exclusion (1)
 p1
 p2
 p3



 Timestamp = 8
 8
 8
 Timestamp = 12
 12
 12
 Prozesses p1 and p3 want to enter critical region
 Prozess p1 has smallest timestamp and wins
*** Example distributed mutual exclusion(2)
 p1
 p2
 p3
 OK
 OK
 OK
 Prozess p1 has smallest timestamp and wins
 p1 enters critical region
*** Example distributed mutual exclusion (3)
 p1
 p2
 p3
 OK
 Once prozess p1 is done, it leaves critical region and sends OK to p3.
 p1 leaves critical region
   p3 enters critical region
 Any problems if these messages are not delivered in atomic order???
*** Algorithm (Ricart and Agrawala, 1981)
 On initialization
 - 	state := RELEASED; 
 - To enter the section
 - 	state := WANTED;
 - 	Multicast request to all processes;		
 - 	T := request’s timestamp;
 - 	Wait until (number of replies received = (N – 1));
 - 	state := HELD;
 - 
 - On receipt of a request <Ti , pi> at pj (i $\not =$ j)
 - 	if  (state = HELD or (state = WANTED and (T, pj) < (Ti, pi)))
 - 	then 
 - 		queue request from pi without replying; 
 - 	else 
 - 		reply immediately to pi;
 - 	end if
 - To exit the critical section
 - 	state := RELEASED;
 - 	reply to all queued requests;
*** Properties of distributed mutual exclusion 
 In simple form, each node turns into a single point of failure 
 - N of them, instead of just one
 - Can be overcome by using additional protocol mechanisms
 - E.g., a more powerful group communication protocol! With terminating reliable multicast 
 - Each process is involved in decision about access to critical region, even if not interested 
 - Possible improvement: simple majority suffices 
 - In total: slower, more complicated, more expensive, less robust
 - 
 - 
 - “Finally, like eating spinach and learning Latin in high school, some things are said to be good for you in some abstract way.” (Tanenbaum) 
 - 
*** Comparison mutual exclusion


** Chubby  lock service 

*** Auxiliary service: Chubby lock service  
 25
 M. Burrows, The Chubby lock service for loosely-coupled distributed systems, proc. of OSDI 2006
*** Chubby design rationale 
 26
*** Chubby system structure 
 27


** Alternative: Zookeeper as support system 

-
  https://www.igvita.com/2010/04/30/distributed-coordination-with-zookeeper/ 
